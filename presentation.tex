\documentclass{beamer}
\usetheme{Warsaw}
%\usecolortheme{seahorse}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\title{C++0x performance improvements}
\author{Łukasz Milewski}
\institute{Uniwersytet Wrocławski}
\date{\today, Wrocław}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{move semantics and perfect forwarding}
\begin{frame}{rationale}
  \begin{block}{Why?}
    \begin{itemize}
    \item Eliminate expensive copying
    \item Solve problems with generic forwarding
    \item Solve usability problems where binding a rvalue to non-const reference is not a logical error
    \end{itemize}
  \end{block}
\end{frame}

\subsection{lvalue, rvalue and rvalue reference}
\begin{frame}{expression category taxonomy}
  \begin{center}
    \includegraphics[5cm]{valuetaxonomy.png}
  \end{center}
\end{frame}

\begin{frame}{lvalue, rvalue, rvalue reference}
  \begin{block}{lvalue}
    \begin{itemize}
    \item Can appear on left-hand side of an assignment expression
    \item if E is expr of pointer type, then *E is an lvalue
    \item calling function whose return type is an lvalue reference is lvalue
    \end{itemize}
  \end{block}

  \begin{block}{rvalue}
    \begin{itemize}
    \item can appear on right-hand side of an assignment expression
    \item xvalue
    \item temporary object
    \item value that is not assosiated with an object
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{example}
  see rvalue\_lvalue.cpp
\end{frame}

\begin{frame}
  \begin{block}{rvalue reference}
    \begin{itemize}
    \item T& - lvalue reference
    \item T&& - rvalue reference
    \item const T&&
    \item binds to lvalues and rvalues
    \item binds to rvalue even if not const qualified
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{binding}
  \begin{block}{binding}
  \item lvalue ref binds to lvalue
  \item const lvalue ref binds to everything
  \item rvalue ref binds to lvalue and nonconst rvalue
  \item const rvalue ref binds to everything
  \end{block}
  see binding.cpp
\end{frame}

\begin{frame}{overload resolution}
  see rvalue\_ref\_resolution.cpp
\end{frame}

\subsection{usability improvements}
\begin{frame}{forwarding arguments}
  \begin{block}{binder problem}
    \begin{itemize}
    \item let's write std::binder2nd class
    \item unbound paramters should behave identically to the corresponding parameters in the original function
    \item const lvalue ref should bind to both lvalue and rvalue
    \item non-const lvalue ref should bind to a non-const lvalue
    \item non-const lvalue should refuse to bind to rvalues and const lvalues
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{forwarding arguments in C++03}
\begin{verbatim}
template <class Operation>
class binder2nd
    : public unary_function<...>
{
    ...
public:
    ...
    result_type operator()(const first_argument_type& x);
    result_type operator()(      first_argument_type& x);
};
\end{verbatim}
\begin{block}{}
  Unfortunately number of overloads grows exponentially with number of
  parameters
\end{block}
\end{frame}

\begin{frame}{forwarding arguments in C++0x}
\begin{verbatim}
template <class Operation>
class binder2nd
    : public unary_function<...>
{
    ...
public:
    ...
    result_type operator()(first_argument_type&& x);
};
\end{verbatim}
\end{frame}

\begin{frame}{move semantics}
\begin{verbatim}
template <class T>
inline
typename remove_reference<T>::type&&
move(T&& t) {
    return t;
}
\end{verbatim}
\begin{block}
  \begin{itemize}
  \item for rvalue reference move returns rvalue reference
  \item for lvalue reference move returns rvalue reference
  \item lvalues are copied while rvalues are moved
  \item std::move enforces moving instead of copying
  \end{itemize}
\end{block}
  see move.cpp
\end{frame}

\begin{frame}{swap trick}
  \begin{block}{c++03 version}
    vector<A>().swap(v);
  \end{block}

  \begin{block}{c++0x version}
    v.swap(vector<A>());
  \end{block}

  \begin{block}{c++0x version}
    swap(v, vector<A>());
  \end{block}
\end{frame}

\subsection{performance improvements}
\begin{frame}{when vector grows}
  \begin{block}{move object when vector grows}
    \begin{itemize}
    \item c++03 copies all objects in vector to new memory
    \item why do that if these objects are about to be destroyed?
    \item c++0x moves all objects in vector to new memory
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{string concatanation}
  std::string tmp = std::string("ala") + " " + "ma" + " " + "kota" + "!";
  \begin{block}{c++03}
    \begin{itemize}
    \item every call to operator+ returns a temporary object
    \item a lot of copying
    \item a lot of dynamic memory allocation
    \item no COW
    \item small strings optimization applies only for small strings
    \end{itemize}
  \end{block}

  \begin{block}{c++0x}
    \begin{itemize}
    \item every call to operator+ returns a temporary object
    \item second temporary string is constructed by stealing the memory owned by the first one
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{RVO & NRVO vs move}
  see rvo.cpp
\end{frame}

\begin{frame}{perfect forwarding}
  \begin{block}{definition}
    If 'foo' calls 'bar' forwarding arguments to it and the same bar
    overload is selected as if bar was called directly then this is
    called perfect forwarding.
  \end{block}
  \begin{block}{function templates}
    If the type of a template function parameter is an rvalue
    \begin{itemize}
    \item reference collapsing
    \item lvalue reference is deduced as lvalue reference
    \item otherwise arameter will bind to rvalues
    \item see perfect\_forwarding.cpp
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{std::forward}
\begin{verbatim}
template <class T>
struct identity {
    typedef T type;
};

template <class T>
inline
T&&
forward(typename identity<T>::type&& t) {
    return t;
}
\end{verbatim}
\end{frame}

\begin{frame}{variadic templates and std::vector::emplace\_back}
  \begin{block}{example}
\begin{verbatim}
#include <string>
#include <vector>

struct A {
public:
    explicit A(int, const std::string&) {
    }
};

int main() {
    std::vector<A> v;
    v.emplace_back(5, "hello");
}
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{implementation}
\begin{verbatim}
#include <iostream>
#include <string>
#include <vector>

struct A {
public:
    explicit A(int x, const std::string& str) {
        std::cout << "A(" << x << ", " << str << ")\n";
    }
};

template <typename... Args>
A create_a(Args&&... args) {
    return A(std::forward<Args>(args)...);
}

int main() {
    A a = create_a(1, "hello");
}
\end{verbatim}
  \end{block}
\end{frame}

\subsection{problems}
\begin{frame}{invariants}
  sea invariant\_problem.cpp
\end{frame}

\section{constexpr}
\section{POD modifications}
\section{multithreading}
\section{alignment}
\section{unique\_ptr}

\end{document}
